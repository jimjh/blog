<!DOCTYPE html>
<html lang="en">

<head>
  <!-- ## for client-side less
  <link rel="stylesheet/less" type="text/css" href="https://blog.jimjh.com/theme/css/style.less">
  <script src="http://cdnjs.cloudflare.com/ajax/libs/less.js/1.7.3/less.min.js" type="text/javascript"></script>
  -->
  <link rel="stylesheet" type="text/css" href="https://blog.jimjh.com/theme/css/style.css">
  <link rel="stylesheet" type="text/css" href="https://blog.jimjh.com/theme/css/pygments.css">
  <link rel="stylesheet" type="text/css" href="//fonts.googleapis.com/css?family=PT+Sans|PT+Serif|PT+Mono">

  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="author" content="James Lim">
  <meta name="description" content="Posts and writings by James Lim">

  <link href="http://feeds.feedburner.com/jimjh/blog" type="application/rss+xml" rel="alternate" title="Ampersand RSS" />

<meta name="keywords" content="ruby, reading">

  <title>
    Ampersand
&ndash; Thoughts from Reading Code - Foreman and Pipes  </title>

<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-5604647-6']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</head>

<body>
  <aside>
    <div id="user_meta">
      <h2><a href="https://blog.jimjh.com">Ampersand</a></h2>
      <p>Moved to Medium in 2019.</p>
      <ul>
        <li><a href="https://medium.com/@jimjh" target="_blank">Medium</a></li>
        <li><a href="https://jimjh.com" target="_blank">Profile</a></li>
      </ul>
    </div>
  </aside>

  <main>
    <header>
      <p>
      <a href="https://blog.jimjh.com">Index</a> &brvbar; <a href="https://blog.jimjh.com/archives.html">Archives</a>
      &brvbar; <a href="http://feeds.feedburner.com/jimjh/blog">RSS</a>
      </p>
    </header>

<article>
  <div class="article_title">
    <h1><a href="https://blog.jimjh.com/thoughts-from-reading-code-foreman-and-pipes.html">Thoughts from Reading Code - Foreman and Pipes</a></h1>
  </div>
  <div class="article_meta">
    <p>Posted on: Mon 12 August 2013</p>
  </div>
  <div class="article_text">
    <h3>Using Pipes for Cheap IPC</h3>
<p>A <a href="https://en.wikipedia.org/wiki/Pipeline_(Unix)">UNIX pipe</a> is a unidirectional interprocess communication channel with
a read end and a write end. You have probably used pipes in the command line.
For example,</p>
<div class="highlight"><pre><span></span>$ git ls-files <span class="p">|</span> xargs grep foo
</pre></div>


<p>This executes both commands concurrently and creates a pipe for interprocess
communication. The output from <code>git ls-files</code> is redirected to the write end of
the pipe, and the input to <code>xargs grep foo</code> is redirected from the read end.</p>
<p>Within foreman, pipes are used to aggregate output from the child process it
manages. A simplified structure of the code is as follows:</p>
<div class="highlight"><pre><span></span><span class="c1"># single process example</span>
<span class="n">process</span> <span class="o">=</span> <span class="n">create_process</span>
<span class="n">reader</span><span class="p">,</span> <span class="n">writer</span> <span class="o">=</span> <span class="n">create_pipe</span>

<span class="c1"># invokes POSIX::Spawn, with STDOUT duped to the pipe</span>
<span class="n">process</span><span class="o">.</span><span class="n">run</span> <span class="ss">output</span><span class="p">:</span> <span class="n">writer</span>
<span class="n">watch_for_output</span> <span class="n">reader</span>
</pre></div>


<h3>Reading from Multiple Pipes</h3>
<p>Of course, Foreman is more useful when it's used to manage multiple processes.
Most of the above is still valid, but <code>watch_for_output</code> must be able to read
from multiple pipes concurrently. Two techniques come to mind: use separate
threads for each pipe, or use an event-based approach such as <code>select</code>. Foreman
uses the latter, because it's harder to coordinate multiple threads with signal
handlers. The former also costs more memory, since it uses a whole stack for
each thread. (For a more detailed comparison of these strategies, please refer
to <a href="http://www.kegel.com/c10k.html#strategies">The C10K problem</a>.)</p>
<p>Inside <a href="https://github.com/ddollar/foreman/blob/master/lib/foreman/engine.rb">Foreman::Engine</a>, <code>select</code> is used in the following way:</p>
<div class="highlight"><pre><span></span><span class="kp">loop</span> <span class="k">do</span>
  <span class="n">io</span> <span class="o">=</span> <span class="no">IO</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="vi">@readers</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span> <span class="c1"># block until a fd is ready</span>
  <span class="n">io</span><span class="o">.</span><span class="n">first</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">reader</span><span class="o">|</span>
    <span class="k">if</span> <span class="n">reader</span><span class="o">.</span><span class="n">eof?</span>
      <span class="vi">@readers</span><span class="o">.</span><span class="n">delete_if</span> <span class="p">{</span> <span class="o">|</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">|</span> <span class="n">value</span> <span class="o">==</span> <span class="n">reader</span> <span class="p">}</span>
    <span class="k">else</span>
      <span class="c1"># read from read end of pipe, send to STDOUT/log file</span>
      <span class="n">output</span> <span class="n">reader</span><span class="o">.</span><span class="n">gets</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>


<h3>Deferring Signals</h3>
<p>Foreman also listens for the <code>TERM</code>, <code>INT</code>, and <code>HUP</code> signals, and terminates
all child processes when one of them is received. However, it's difficult to
write reentrant signal handlers in Ruby, since developers do not have complete
control over which C functions are called. Thus, it's usually recommended to
<a href="http://blog.rubybestpractices.com/posts/ewong/016-Implementing-Signal-Handlers.html">defer signal handling</a> by pushing signals onto a queue and handling
them sequentially. For example,</p>
<div class="highlight"><pre><span></span><span class="c1"># push signals onto a queue</span>
<span class="nb">trap</span><span class="p">(</span><span class="s1">&#39;INT&#39;</span><span class="p">)</span> <span class="p">{</span> <span class="n">some_queue</span> <span class="o">&lt;&lt;</span> <span class="ss">:INT</span> <span class="p">}</span>

<span class="no">Thread</span><span class="o">.</span><span class="n">new</span> <span class="k">do</span>
  <span class="n">process_queue</span>
<span class="k">end</span>
</pre></div>


<p>This presents new problems. In the <code>select</code> example above, the thread is
blocked while waiting for one or more of the file descriptors to become ready.
We need a way to interrupt the thread so that it may exit gracefully when a
signal is received. Moreover, <code>process_queue</code> needs to know when a signal has
been received, so that it does not have to poll the queue for changes. To solve
these, Foreman uses the self-pipe trick.</p>
<h4>The Self-Pipe Trick</h4>
<p>A self-pipe is a pipe that is not shared outside the process that created the
pipe. In the scenario described above, Foreman creates a self-pipe and adds it
to the list of inputs that <code>select</code> waits on.</p>
<div class="highlight"><pre><span></span><span class="n">io</span> <span class="o">=</span> <span class="no">IO</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">[</span><span class="n">self_pipe_read</span><span class="o">]</span> <span class="o">+</span> <span class="vi">@readers</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>
</pre></div>


<p>Then, whenever <code>select</code> needs to be interrupted, a dummy value is written on
the write end of the self-pipe, causing <code>select</code> to return. The code following
<code>select</code> will have to determine if <code>select</code> has found valid input from one of
the readers, or if it was interrupted for another reason. For Foreman, it needs
to check if there are pending signals in the queue that needs to be handled.</p>
<p>This kills two birds with one stone.</p>
<div class="highlight"><pre><span></span><span class="no">Thread</span><span class="o">.</span><span class="n">new</span> <span class="k">do</span>
  <span class="kp">loop</span> <span class="k">do</span>
    <span class="n">io</span> <span class="o">=</span> <span class="no">IO</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">[</span><span class="n">self_pipe_read</span><span class="o">]</span> <span class="o">+</span> <span class="vi">@readers</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="kp">nil</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>
    <span class="n">process_queue</span>
    <span class="n">io</span><span class="o">.</span><span class="n">first</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">reader</span><span class="o">|</span>
    <span class="k">if</span> <span class="n">reader</span><span class="o">.</span><span class="n">eof?</span>
      <span class="vi">@readers</span><span class="o">.</span><span class="n">delete_if</span> <span class="p">{</span> <span class="o">|</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="o">|</span> <span class="n">value</span> <span class="o">==</span> <span class="n">reader</span> <span class="p">}</span>
    <span class="k">else</span>
      <span class="c1"># read from read end of pipe, send to STDOUT/log file</span>
      <span class="n">output</span> <span class="n">reader</span><span class="o">.</span><span class="n">gets</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
  </div>
  <div class="article_meta">
    <p>Category: <a href="https://blog.jimjh.com/category/software.html">Software</a>
 &ndash; Tags:
      <a href="https://blog.jimjh.com/tag/ruby.html">ruby</a>,      <a href="https://blog.jimjh.com/tag/reading.html">reading</a>    </p>
  </div>

  <div id="article_comments">
    <div id="disqus_thread"></div>
    <script type="text/javascript">
        var disqus_identifier = "thoughts-from-reading-code-foreman-and-pipes.html";
        (function() {
             var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
             dsq.src = '//jimjh.disqus.com/embed.js';
             (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
         })();
    </script>
  </div>

</article>


    <div id="ending_message">
      <p>&copy; James Lim. Built using <a href="http://getpelican.com" target="_blank">Pelican</a>. Theme by Giulio Fidente on <a href="https://github.com/gfidente/pelican-svbhack" target="_blank">github</a>. </p>
    </div>
  </main>
</body>
</html>